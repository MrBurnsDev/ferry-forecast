/**
 * Route Exposure Configuration - V2 Shelter Signature
 * =====================================================
 *
 * Loads computed route exposure data using the shelter-signature algorithm.
 * V2 replaces fetch-distance with local shelter classification for better
 * accuracy in coastal/island regions.
 *
 * Algorithm (v2):
 * - 50 sample points per route (up from 10)
 * - For each wind direction, cast 30km ray upwind
 * - Point is "sheltered" if land within 3km
 * - shelter_ratio = fraction of points NOT sheltered (open)
 *   - 1.0 = fully open (all rays travel 30km without hitting land)
 *   - 0.0 = fully sheltered (all rays hit land within 3km)
 *
 * Data is generated by scripts/compute_route_exposure_v2.py using
 * Natural Earth 10m coastline data.
 *
 * Validation:
 * - Hyannis-Nantucket must have higher shelter_ratio than Woods Hole-Vineyard Haven
 *   by at least 0.2 (geographically correct: 44km open water vs 10km sound crossing)
 */

// V2 format - load shelter signature data
// Falls back to v1 format for backwards compatibility during migration
import routeExposureDataV1 from './route_exposure.json';

// 16-point compass directions
export const COMPASS_DIRECTIONS = [
  'N', 'NNE', 'NE', 'ENE',
  'E', 'ESE', 'SE', 'SSE',
  'S', 'SSW', 'SW', 'WSW',
  'W', 'WNW', 'NW', 'NNW',
] as const;

export type CompassDirection = typeof COMPASS_DIRECTIONS[number];

// V1 format (legacy)
export interface RouteExposureV1 {
  route_id: string;
  origin_port: string;
  destination_port: string;
  exposure_by_dir: Record<CompassDirection, number>;
  fetch_km_by_dir: Record<CompassDirection, number>;
  avg_exposure: number;
  top_exposure_dirs: CompassDirection[];
}

// V2 format (shelter signature)
export interface RouteExposureV2 {
  route_id: string;
  origin_port: string;
  destination_port: string;
  shelter_ratio_by_dir: Record<CompassDirection, number>;
  effective_open_fetch_km_by_dir: Record<CompassDirection, number>;
  mean_shelter_ratio: number;
  top_exposure_dirs: CompassDirection[];
}

// Unified interface for consumers
export interface RouteExposure {
  route_id: string;
  origin_port: string;
  destination_port: string;
  /** Exposure score per direction (0-1, higher = more exposed) */
  exposure_by_dir: Record<CompassDirection, number>;
  /** Fetch distance per direction in km */
  fetch_km_by_dir: Record<CompassDirection, number>;
  /** Average exposure across all directions */
  avg_exposure: number;
  /** Top 3 most exposed directions */
  top_exposure_dirs: CompassDirection[];
  /** Data version */
  version: '1' | '2';
}

interface RouteExposureFileV1 {
  version: string;
  computed_at: string;
  parameters: {
    sample_points: number;
    max_fetch_km: number;
    ray_step_m: number;
    note?: string;
  };
  routes: Record<string, RouteExposureV1>;
}

interface RouteExposureFileV2 {
  version: string;
  algorithm: 'shelter_signature';
  computed_at: string;
  parameters: {
    sample_points: number;
    max_ray_km: number;
    shelter_threshold_km: number;
    ray_step_m: number;
    compass_buckets: number;
  };
  routes: Record<string, RouteExposureV2>;
}

// Try to load V2, fall back to V1
let exposureDataV2: RouteExposureFileV2 | null = null;
let usingV2 = false;

try {
  // Dynamic import would be cleaner but we need sync access
  // V2 file will be generated by compute_route_exposure_v2.py
  // For now, check if v2 data exists in the v1 file structure
  const v1Data = routeExposureDataV1 as RouteExposureFileV1 | RouteExposureFileV2;
  if ('algorithm' in v1Data && v1Data.algorithm === 'shelter_signature') {
    exposureDataV2 = v1Data as unknown as RouteExposureFileV2;
    usingV2 = true;
  }
} catch {
  // V2 not available, use V1
}

const exposureFileV1 = routeExposureDataV1 as RouteExposureFileV1;

/**
 * Convert V2 shelter signature to unified format
 */
function convertV2ToUnified(v2: RouteExposureV2): RouteExposure {
  return {
    route_id: v2.route_id,
    origin_port: v2.origin_port,
    destination_port: v2.destination_port,
    // shelter_ratio IS the exposure score (1=open/exposed, 0=sheltered)
    exposure_by_dir: v2.shelter_ratio_by_dir,
    fetch_km_by_dir: v2.effective_open_fetch_km_by_dir,
    avg_exposure: v2.mean_shelter_ratio,
    top_exposure_dirs: v2.top_exposure_dirs as CompassDirection[],
    version: '2',
  };
}

/**
 * Convert V1 format to unified format
 */
function convertV1ToUnified(v1: RouteExposureV1): RouteExposure {
  return {
    ...v1,
    version: '1',
  };
}

/**
 * Get exposure data for a specific route
 */
export function getRouteExposure(routeId: string): RouteExposure | null {
  if (usingV2 && exposureDataV2) {
    const v2Route = exposureDataV2.routes[routeId];
    if (v2Route) {
      return convertV2ToUnified(v2Route);
    }
  }

  const v1Route = exposureFileV1.routes[routeId];
  if (v1Route) {
    return convertV1ToUnified(v1Route);
  }

  return null;
}

/**
 * Get all routes with exposure data
 */
export function getAllRouteExposures(): Record<string, RouteExposure> {
  const result: Record<string, RouteExposure> = {};

  if (usingV2 && exposureDataV2) {
    for (const [id, route] of Object.entries(exposureDataV2.routes)) {
      result[id] = convertV2ToUnified(route);
    }
  } else {
    for (const [id, route] of Object.entries(exposureFileV1.routes)) {
      result[id] = convertV1ToUnified(route);
    }
  }

  return result;
}

/**
 * Get exposure metadata (version, computation time, etc.)
 */
export function getExposureMetadata(): {
  version: string;
  algorithm: string;
  computed_at: string;
  usingV2: boolean;
  parameters: Record<string, unknown>;
} {
  if (usingV2 && exposureDataV2) {
    return {
      version: exposureDataV2.version,
      algorithm: exposureDataV2.algorithm,
      computed_at: exposureDataV2.computed_at,
      usingV2: true,
      parameters: exposureDataV2.parameters,
    };
  }

  return {
    version: exposureFileV1.version,
    algorithm: 'fetch_distance',
    computed_at: exposureFileV1.computed_at,
    usingV2: false,
    parameters: exposureFileV1.parameters,
  };
}

/**
 * Convert wind direction in degrees to nearest compass bucket
 *
 * @param degrees - Wind direction in degrees (0-360)
 * @returns Nearest compass direction
 */
export function degreesToCompassBucket(degrees: number): CompassDirection {
  // Normalize to 0-360
  const normalized = ((degrees % 360) + 360) % 360;

  // Each compass point spans 22.5 degrees (360 / 16)
  const index = Math.round(normalized / 22.5) % 16;

  return COMPASS_DIRECTIONS[index];
}

/**
 * Get exposure score for a route given a wind direction
 *
 * @param routeId - Route identifier (e.g., 'wh-vh-ssa')
 * @param windFromDegrees - Wind direction in degrees (where wind is coming FROM)
 * @returns Exposure score 0..1, or null if route not found
 */
export function getExposureForDirection(
  routeId: string,
  windFromDegrees: number
): number | null {
  const exposure = getRouteExposure(routeId);
  if (!exposure) return null;

  const compassDir = degreesToCompassBucket(windFromDegrees);
  return exposure.exposure_by_dir[compassDir] ?? null;
}

/**
 * Calculate route exposure modifier for scoring - V2 Algorithm
 *
 * Uses linear interpolation (lerp) from shelter_ratio to modifier:
 * - shelter_ratio 0.0 (fully sheltered) → -8 points
 * - shelter_ratio 0.5 (neutral)         → +2 points (slight penalty for open water)
 * - shelter_ratio 1.0 (fully open)      → +12 points
 *
 * This is a simpler, more predictable formula than v1's piecewise function.
 * The bounds [-8, +12] prevent exposure from dominating the overall score.
 *
 * @param routeId - Route identifier
 * @param windFromDegrees - Wind direction in degrees
 * @returns Modifier in range [-8, +12], or 0 if route not found
 */
export function calculateExposureModifier(
  routeId: string,
  windFromDegrees: number
): number {
  const exposure = getExposureForDirection(routeId, windFromDegrees);

  if (exposure === null) {
    return 0; // No data, no modification
  }

  // V2: Linear interpolation from shelter_ratio to modifier
  // lerp(-8, +12, exposure) where exposure is shelter_ratio (0=sheltered, 1=open)
  // Formula: min + (max - min) * t = -8 + (12 - (-8)) * exposure = -8 + 20 * exposure
  const modifier = -8 + 20 * exposure;

  return Math.round(modifier);
}

/**
 * Get formatted top exposure directions for display
 *
 * @param routeId - Route identifier
 * @returns Array of top 3 directions, or null if route not found
 */
export function getTopExposureDirections(routeId: string): CompassDirection[] | null {
  const exposure = getRouteExposure(routeId);
  if (!exposure) return null;

  return exposure.top_exposure_dirs;
}

/**
 * Format a direction with "winds" suffix for display
 *
 * @param direction - Compass direction
 * @returns Formatted string like "SW winds"
 */
export function formatDirectionLabel(direction: CompassDirection): string {
  return `${direction} winds`;
}

/**
 * Check if we're using the V2 shelter signature algorithm
 */
export function isUsingV2Algorithm(): boolean {
  return usingV2;
}
